<!DOCTYPE html>
<html lang='ja'>
<head>
<title>君もelixirを始めてみないか | dev.wan.co</title>
<meta charset='utf-8'>
<meta content='elixir' name='keywords'>
<meta content='elixirの始め方' name='description'>
<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-43663109-1', 'k-shogo.github.io');
  ga('send', 'pageview');
</script>

<!--[if lte IE 8]> <script src="js/html5shiv.js"></script> <![endif]-->
<script src="/js/all.js" type="text/javascript"></script>
<link href="/css/main.css" rel="stylesheet" type="text/css" />
</head>
<body>
<noscript>
<link href="/css/skel-noscript.css" rel="stylesheet" type="text/css" /><link href="/css/style.css" rel="stylesheet" type="text/css" /><link href="/css/style-desktop.css" rel="stylesheet" type="text/css" /><link href="/css/style-noscript.css" rel="stylesheet" type="text/css" />
</noscript>
<!--[if lte IE 8]> <link rel="stylesheet" href="css/ie8.css" /> <![endif]-->
<!-- Header -->
<div id='header'>
<!-- Inner -->
<div class='inner'>
<header>
<h1>
<div id='logo'><a href="/">Dev.Wan.Co</a></div>
</h1>
</header>
</div>
<!-- Nav -->
<nav id='nav'>
<ul>
<li>
<a href="/">Home</a>
</li>
<li>
<a href="/feed.xml">RSS Feed</a>
</li>
</ul>
</nav>
</div>
<!-- Main -->
<div class='wrapper style1'>
<div class='container'>
<div class='row'>
<div class='12u skel-cell-important' id='content'>
<article class='special' id='main'>
<header>
<h2>君もelixirを始めてみないか</h2>
<span class='byline'>
<a href="/article/tags/elixir/">elixir</a>
</span>
</header>
<section><header><h3>elixirって何？</h3></header>

<p><a href="http://elixir-lang.org">elixir</a> (エリクサー)は<a href="http://www.erlang.org">Erlang</a>で作られた言語なんだ。<br>
最初はCoffeeScriptとJavaScriptみたいな関係なのかって思ってくれれば良い。<br>
Erlangの上に作られているから、elixirの特徴を語るにはまずErlangについて述べる必要がある。</p>

<p>Erlangは1986年にJoe Armstrong, Robert Virding, Mike Williams の3人によって最初のバージョンが作られた。<br>
元々は通信機器メーカーのEricsson内部の独自言語だったけれど、1998年にオープンソースとしてリリースされた。<br>
Erlangの特徴をぎゅっとまとめると、並行性と信頼性そしてホットスワップだ。<br>
Erlangの開発は Joe Armstrong 博士が電話交換制御用ソフトウェアを構築するために、<br>
Prologをベースに並行プロセスやエラー処理の仕組みを追加したことに端を発している。<br>
並行性と信頼性、ホットスワップの特徴は通信事業者向けの分散アプリケーションの開発に必要だったんだ。</p>

<p>elixirはBEAMと呼ばれるErlangの仮想環境で動作するから、Erlangの並行性と信頼性の特徴を受け継いでいる。<br>
そして拡張機能としてマクロを使ったメタプログラミング等も扱うことが出来るんだ。</p>

<p>elixirよりまず、Erlangの知名度も高くは無いよね。<br>
でも案外身近なところで使われてたりするんだ。<br>
Twitterでは<a href="https://www.ejabberd.im">ejabberd</a>というJabber/XMPP実装が使われている（今現在もそうかは分からないけど）ようだし、<a href="https://www.erlang-solutions.com/about/news/whatsapp-engineers-talk-about-scaling-450-million-users-erlang-erlang-factory-sf-bay-6-7">WhatsAppもErlangを使用しているみたいだ</a>。<br>
Erlangは何億人とユーザーを抱えるような大規模なシステムでかなりの実績を積んでいる。<br>
プロセッサのマルチコア化が進む現在、並行性と信頼性を備えるErlangが活躍できる場面が多くなっていくんじゃないかなって思わないかい？<br>
Matzも注目する言語なんて記事もあるよ。</p>

<ul>
<li><a href="http://magazine.rubyist.net/?0017-Legwork">Rubyist Magazine - Rubyist のための他言語探訪 【第 10 回】 Erlang</a></li>
<li><a href="http://www.atmarkit.co.jp/news/200704/27/erlang.html">twitterブームの陰で注目を集める“Erlang” － ＠IT</a></li>
<li><a href="http://techon.nikkeibp.co.jp/article/TOPCOL/20070710/135665/">組み込みから生まれた言語Erlangの時代が来る - 日経エレクトロニクス - 日経テクノロジーオンライン</a></li>
</ul>

<p>そんなに言うならelixirじゃなくて素のErlangで良いじゃんって思うかもしれないね。<br>
答える代わりに質問だ、上の記事は2007の物なんだけど、Erlangって今流行ってる？<br>
ちょっとこの記事を見て欲しい&quot;<a href="http://www.infoq.com/jp/news/2012/01/Katz-CouchDB-Couchbase-Server">Damien Katz氏がApache CouchDBから離反し、Couchbase Server開発を継続</a>&ldquo;CouchDBがコードの大半をErlangからC/C++するって内容だ。<br>
Damien Katz氏はインタビューの中で流行ってない原因を述べている。</p>

<blockquote>
<p>Erlangは素晴らしい言語です。信頼性が高く、信頼できるしっかりとしたシステムを簡単に構築できます。しかし、エコシステムがとても小さいです。なので、ツールや性能に対する投資は他の一般的な言語とは比べようもないくらい少ないです。私はErlangにもっと人気の言語になって欲しいと思います。ErlangがJavaよりも速くならない理由はどこにもありません。しかし、その奇妙な構文が人々を遠ざけ、普及と商用投資を妨げています。でも私はErlangが好きです。性能が重要なコンポーネントでの利用は少なくしますが、今後も致命的に重要なコンポーネントに使うつもりです。</p>
</blockquote>

<p>そう、流行らないのは取っつきにくいからだ。<br>
であれば、取っつきやすければ Erlang のパワーを享受できるようになるね。<br>
そういう考えで始まったプロジェクトには<a href="http://reia-lang.org/">Reia Programming Language</a>という物もある、しかし残念ながらReiaの開発は停止してしまっている。<br>
Reiaの後に登場し、後継のプロジェクトに指名され、2014年9月18日にv1.0.0がリリースされたのがelixirなんだ。</p>

</section><section><header><h3>開発環境は整ってるの？</h3></header>

<p>何が取っつきやすくなったかって、それはもちろん文法なんだけど、<br>
今や言語そのものが良くたって開発環境が良くないと流行らないよね。<br>
だから文法の前に開発の環境について紹介しておくね。<br>
僕は普段はrubyを使っているから、rubyの環境と対比させて紹介するね。</p>

<p>まずは <code>Mix</code> だ。<br>
<code>Mix</code> は ruby だと <code>rake</code> と <code>bundler</code> を合わせたようなものなんだ。<br>
rubyのプロジェクト開始は <code>bundle init</code> して、<code>Gemfile</code> を編集して、<code>bundle install</code>するよね。</p>
<pre class="highlight shell"><code><span class="gp">$ </span>mkdir ruby_app
<span class="gp">$ </span><span class="nb">cd </span>ruby_app
<span class="gp">$ </span>bundle init
<span class="gp">$ </span>vim Gemfile
</code></pre>
<pre class="highlight ruby"><code><span class="n">source</span> <span class="s2">"https://rubygems.org"</span>

<span class="n">gem</span> <span class="s2">"rails"</span>
</code></pre>
<pre class="highlight shell"><code><span class="gp">$ </span>bundle install
</code></pre>

<p><code>elixir</code> の <code>mix</code> の場合は <code>mix new elixir_app</code> して <code>mix.exs</code> の <code>deps</code> を編集して、<code>mix deps.get</code> だ。<br>
ここでは <code>deps</code> に <a href="https://github.com/elixir-lang/ecto">elixir-lang/ecto</a> というライブラリを追加している。</p>
<pre class="highlight shell"><code><span class="gp">$ </span>mix new elixir_app
<span class="gp">$ </span><span class="nb">cd </span>elixir_app
<span class="gp">$ </span>vim mix.exs
</code></pre>
<pre class="highlight elixir"><code><span class="k">defmodule</span> <span class="no">ElixirApp</span><span class="o">.</span><span class="no">Mixfile</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Mix</span><span class="o">.</span><span class="no">Project</span>

  <span class="k">def</span> <span class="n">project</span> <span class="k">do</span>
    <span class="p">[</span><span class="ss">app:</span> <span class="ss">:elixir_app</span><span class="p">,</span>
     <span class="ss">version:</span> <span class="sd">"</span><span class="s2">0.0.1"</span><span class="p">,</span>
     <span class="ss">elixir:</span> <span class="sd">"</span><span class="s2">~&gt; 1.0"</span><span class="p">,</span>
     <span class="ss">deps:</span> <span class="n">deps</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="c1"># Configuration for the OTP application</span>
  <span class="c1">#</span>
  <span class="c1"># Type `mix help compile.app` for more information</span>
  <span class="k">def</span> <span class="n">application</span> <span class="k">do</span>
    <span class="p">[</span><span class="ss">applications:</span> <span class="p">[</span><span class="ss">:logger</span><span class="p">]]</span>
  <span class="k">end</span>

  <span class="c1"># Dependencies can be Hex packages:</span>
  <span class="c1">#</span>
  <span class="c1">#   {:mydep, "~&gt; 0.3.0"}</span>
  <span class="c1">#</span>
  <span class="c1"># Or git/path repositories:</span>
  <span class="c1">#</span>
  <span class="c1">#   {:mydep, git: "https://github.com/elixir-lang/mydep.git", tag: "0.1.0"}</span>
  <span class="c1">#</span>
  <span class="c1"># Type `mix help deps` for more examples and options</span>
  <span class="k">defp</span> <span class="n">deps</span> <span class="k">do</span>
    <span class="p">[</span>
      <span class="p">{</span><span class="ss">:ecto</span><span class="p">,</span> <span class="sd">"</span><span class="s2">~&gt; 0.4"</span><span class="p">}</span>
    <span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<pre class="highlight shell"><code><span class="gp">$ </span>mix deps.get
</code></pre>

<p>rubyでの<a href="https://rubygems.org/">RubyGems.org</a>に対応するライブラリのホスティングは<a href="https://hex.pm/">Hex</a>という物があるし、<br>
依存関係には <a href="https://github.com/">GitHub</a> のリポジトリを指定することも出来る。</p>

<p>インタラクティブシェルは <code>irb</code> に相当する <code>iex</code> が用意されているし、テストも標準で <code>ExUnit</code> という物がある。<br>
さらに、是非紹介しておきたいのが Elixir Release Manager <a href="https://github.com/bitwalker/exrm">bitwalker/exrm</a>だ。<br>
詳しい使い方は後に回すけれど、exrm はリリース用のビルドを行うことが出来るし、さらにダウンタイムなしのアップグレードやダウングレードを簡単にしてくれる。</p>

<table><thead>
<tr>
<th style="text-align: left">機能</th>
<th style="text-align: left">ruby</th>
<th style="text-align: left">elixir</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">ビルドツール</td>
<td style="text-align: left">rake</td>
<td style="text-align: left">mix</td>
</tr>
<tr>
<td style="text-align: left">ライブラリ管理</td>
<td style="text-align: left">bundle</td>
<td style="text-align: left">mix</td>
</tr>
<tr>
<td style="text-align: left">標準リポジトリ</td>
<td style="text-align: left">RubyGems.org</td>
<td style="text-align: left">Hex</td>
</tr>
<tr>
<td style="text-align: left">インタラクティブシェル</td>
<td style="text-align: left">irb</td>
<td style="text-align: left">iex</td>
</tr>
<tr>
<td style="text-align: left">テスト</td>
<td style="text-align: left">minitest</td>
<td style="text-align: left">ExUnit</td>
</tr>
</tbody></table>

<p>エディターのサポートは、vim(<a href="https://github.com/elixir-lang/vim-elixir">vim elixir-lang/vim-elixir</a>)と emacs(<a href="https://github.com/elixir-lang/emacs-elixir">elixir-lang/emacs-elixir</a>)とAtom(<a href="https://github.com/lucasmazza/language-elixir">lucasmazza/language-elixir</a>)があるから大丈夫かな？（他にもgeditとTextmateも用意されているよ）</p>

</section><section><header><h3>はじめてみよう</h3></header>

<p>始めて見るにはまずelixirをインストールしないとね。<br>
もしMacを使っていて、すでに<code>brew</code>を使っているのであればとても簡単</p>
<pre class="highlight shell"><code><span class="gp">$ </span>brew update
<span class="gp">$ </span>brew install elixir
</code></pre>

<p>Ubuntu を使っているなら、リポジトリを追加して<code>apg-get</code>で入る</p>
<pre class="highlight shell"><code><span class="gp">$ </span>wget http://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb <span class="o">&amp;&amp;</span> sudo dpkg -i erlang-solutions_1.0_all.deb
<span class="gp">$ </span>sudo apt-get update
<span class="gp">$ </span>sudo apt-get install elixir
</code></pre>

<p>Windowsの場合は<a href="http://s3.hex.pm/elixir-websetup.exe">インストーラー</a>が用意されているよ。</p>

<p>これで基本的にはErlangも一緒に入っている。<br>
早速使い始めてみよう。<code>iex</code>コマンドでインタラクティブシェルが立ち上がる</p>
<pre class="highlight elixir"><code><span class="no">Erlang</span><span class="o">/</span><span class="no">OTP</span> <span class="m">17</span> <span class="p">[</span><span class="n">erts</span><span class="o">-</span><span class="m">6.3</span><span class="p">]</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="p">[</span><span class="m">64</span><span class="o">-</span><span class="n">bit</span><span class="p">]</span> <span class="p">[</span><span class="ss">smp:</span><span class="m">4</span><span class="p">:</span><span class="m">4</span><span class="p">]</span> <span class="p">[</span><span class="n">async</span><span class="o">-</span><span class="ss">threads:</span><span class="m">10</span><span class="p">]</span> <span class="p">[</span><span class="n">hipe</span><span class="p">]</span> <span class="p">[</span><span class="n">kernel</span><span class="o">-</span><span class="ss">poll:</span><span class="no">false</span><span class="p">]</span> <span class="p">[</span><span class="n">dtrace</span><span class="p">]</span>

<span class="no">Interactive</span> <span class="no">Elixir</span> <span class="p">(</span><span class="m">1.0</span><span class="o">.</span><span class="m">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">press</span> <span class="no">Ctrl</span><span class="o">+</span><span class="no">C</span> <span class="n">to</span> <span class="k">exit</span> <span class="p">(</span><span class="n">type</span> <span class="n">h</span><span class="p">()</span> <span class="no">ENTER</span> <span class="n">for</span> <span class="n">help</span><span class="p">)</span>
<span class="n">iex</span><span class="o">&gt;</span>
</code></pre>

<p>終了したいときは<code>Ctrl+C</code>して<code>(a)bort</code>の<code>a</code>をタイプしてエンターだ。</p>

<p>実はErlang(<code>erl</code>で起動するよ)だと式の最後に<code>.</code>ピリオドを付けなきゃならない</p>
<pre class="highlight erlang"><code><span class="nv">Erlang</span><span class="o">/</span><span class="nv">OTP</span> <span class="mi">17</span> <span class="p">[</span><span class="n">erts</span><span class="o">-</span><span class="mi">6</span><span class="p">.</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="p">[</span><span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="p">]</span> <span class="p">[</span><span class="nn">smp</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="p">[</span><span class="n">async</span><span class="o">-</span><span class="nn">threads</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="p">[</span><span class="n">hipe</span><span class="p">]</span> <span class="p">[</span><span class="n">kernel</span><span class="o">-</span><span class="nn">poll</span><span class="p">:</span><span class="n">false</span><span class="p">]</span> <span class="p">[</span><span class="n">dtrace</span><span class="p">]</span>

<span class="nv">Eshell</span> <span class="nv">V6</span><span class="p">.</span><span class="mi">3</span>  <span class="p">(</span><span class="n">abort</span> <span class="n">with</span> <span class="err">^</span><span class="nv">G</span><span class="p">)</span>
<span class="mi">1</span><span class="o">&gt;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">.</span>
<span class="mi">3</span>
</code></pre>

<p>でもelixirならピリオドはいらない、そのまま<code>1+2</code>とタイプしてエンターで計算できる。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span><span class="o">+</span><span class="m">2</span>
<span class="m">3</span>
</code></pre>

<p>このまま進む前に、elixirのインストールによって入った他のコマンドも紹介しておこう。<br>
<code>elixir</code>と<code>elixirc</code>だ。<br>
<code>elixir</code>コマンドはelixirスクリプトを実行する物だ。<br>
<code>ruby hoge.rb</code>みたいな感じで、<code>elixir hoge.exs</code>と使用する。<br>
<code>elixirc</code>はコンパイル用のコマンドで、<code>elixirc hoge.ex</code>とするとコンパイルされた<code>.beam</code>ファイルが生成される。<br>
ファイルの拡張子を<code>.exs</code>と<code>.ex</code>を登場させたけれど、<br>
<code>.exs</code>はコンパイルしないで実行するスクリプトファイル、<br>
<code>.ex</code>はコンパイルするファイルに付けるのが習慣なんだ。</p>

<p>他には今後よく使う表記について説明しておこう。<br>
elixirでは関数は&quot;モジュール名&rdquo;, &ldquo;関数名&rdquo;, &ldquo;アリティ&quot;（つまり引数の個数）によって一意に定まる。<br>
だから関数を表現するときに <code>モジュール.関数/アリティ</code>といった具合に表記する。<br>
例えば<code>IO.puts/1</code>とかね。<br>
これはiexからドキュメントを見るときにも使うよ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">(</span><span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="o">/</span><span class="m">1</span><span class="p">)</span>

                <span class="k">def</span> <span class="n">puts</span><span class="p">(</span><span class="n">device</span> <span class="p">\\</span> <span class="ss">:erlang</span><span class="o">.</span><span class="n">group_leader</span><span class="p">(),</span> <span class="n">item</span><span class="p">)</span>

<span class="no">Writes</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">the</span> <span class="n">device</span><span class="p">,</span> <span class="n">similar</span> <span class="n">to</span> <span class="n">write</span><span class="o">/</span><span class="m">2</span><span class="p">,</span> <span class="n">but</span> <span class="n">adds</span> <span class="n">a</span> <span class="n">newline</span> <span class="n">at</span>
<span class="n">the</span> <span class="k">end</span><span class="o">.</span> <span class="no">The</span> <span class="n">argument</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="n">be</span> <span class="n">a</span> <span class="n">chardata</span><span class="o">.</span>
</code></pre>

</section><section><header><h3>まずは基本的な型だ</h3></header>

<h4>整数、浮動小数、文字列</h4>

<p>基本的な型を確認してみよう</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span><span class="o">+</span><span class="m">2</span>
<span class="m">3</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span><span class="o">+</span><span class="m">2.0</span>
<span class="m">3.0</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="sd">"</span><span class="s2">string"</span>
<span class="sd">"</span><span class="s2">string"</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="o">+</span> <span class="sd">"</span><span class="s2">string"</span>
<span class="o">**</span> <span class="p">(</span><span class="no">ArithmeticError</span><span class="p">)</span> <span class="n">bad</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">arithmetic</span> <span class="n">expression</span>
    <span class="ss">:erlang</span><span class="o">.+</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="sd">"</span><span class="s2">string"</span><span class="p">)</span>
</code></pre>

<p>整数、浮動小数点、文字列が使えることが分かった。<br>
整数と浮動小数点の計算ではエラーにならずに自動的に型の変換もしてくれる。<br>
暗黙に変換できな場合はもちろんエラーになる。<br>
ちなみにelixirの浮動小数点は64ビットの倍精度だ。<br>
四則演算は当然出来るんだけど、ちょっと注意なのが<code>/</code>による除算だ。<br>
irbで<code>10 / 3</code>とやれば<code>3</code>が出力されるけど、iexなら浮動小数点で返る。<br>
整数の商が欲しければ<code>div</code>関数が用意されている。<br>
rubyと同じで自明なカッコは省略も出来る。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">10</span> <span class="o">/</span> <span class="m">3</span>
<span class="m">3.3333333333333335</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">div</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="m">3</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">div</span> <span class="m">10</span><span class="p">,</span> <span class="m">3</span>
<span class="m">3</span>
</code></pre>

<p>二進数、八進数、十六進数、そして指数表記もサポートしている。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">0b11111011111</span>
<span class="m">2015</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="err">0</span><span class="n">o77</span>
<span class="m">63</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="m">0xff</span>
<span class="m">255</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="m">1.0e-10</span>
<span class="m">1.0e-10</span>
</code></pre>

<h4>真偽値</h4>

<p>真偽値は<code>true</code>,<code>false</code>だ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="no">true</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">false</span>
<span class="no">false</span>
</code></pre>

<p>真偽値では無いけれど<code>nil</code>も用意されている</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="no">nil</span>
<span class="no">nil</span>
</code></pre>

<p>論理演算は<code>and</code>,<code>or</code>,<code>not</code>だ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="no">true</span> <span class="ow">and</span> <span class="no">false</span>
<span class="no">false</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">true</span> <span class="ow">or</span> <span class="no">false</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="ow">not</span> <span class="no">false</span>
<span class="no">true</span>
</code></pre>

<p>論理演算には<code>&amp;&amp;</code>,<code>||</code>,<code>!</code>も用意されている。<br>
違いは真偽値だけ受け付けるか、任意の型を受け付けるかだ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="ow">and</span> <span class="no">true</span>
<span class="o">**</span> <span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span> <span class="n">argument</span> <span class="ss">error:</span> <span class="m">1</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="o">&amp;&amp;</span> <span class="no">true</span>
<span class="no">true</span>
</code></pre>

<p><code>&amp;&amp;</code>,<code>||</code>,<code>!</code>の場合、<code>false</code>と<code>nil</code>以外を真として評価する。<br>
rubyと一緒だね。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="ow">not</span> <span class="m">1</span>
<span class="o">**</span> <span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span> <span class="n">argument</span> <span class="n">error</span>
    <span class="ss">:erlang</span><span class="o">.</span><span class="ow">not</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">!</span> <span class="m">1</span>
<span class="no">false</span>
</code></pre>

<p><code>or</code>, <code>and</code>, <code>||</code>, <code>&amp;&amp;</code>は短絡演算子、つまり左辺が条件を満たさない場合は右辺は評価されない。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="o">**</span> <span class="p">(</span><span class="no">RuntimeError</span><span class="p">)</span> <span class="n">undefined</span> <span class="ss">function:</span> <span class="n">x</span><span class="o">/</span><span class="m">0</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="no">true</span> <span class="ow">or</span> <span class="n">x</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">true</span> <span class="o">||</span> <span class="n">x</span>
<span class="no">true</span>
</code></pre>

<p>ここまで紹介してきた型は<code>is_integer/1</code>, <code>is_float/1</code>, <code>is_number/1</code>, <code>is_boolean/1</code> で判定できるよ。<br>
<code>is_number/1</code>は整数もしくは浮動小数点の場合に<code>true</code>だね。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">is_number</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">is_number</span><span class="p">(</span><span class="m">1.0</span><span class="p">)</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">is_number</span><span class="p">(</span><span class="no">true</span><span class="p">)</span>
<span class="no">false</span>
</code></pre>

<h4>アトム</h4>

<p>次はアトムだ。アトムは<code>:</code>から始まるもので、rubyだとシンボルって呼ばれているね。<br>
真偽値の<code>true</code>, <code>false</code>は実はアトムなんだ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="no">true</span> <span class="o">==</span> <span class="ss">:true</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">is_atom</span><span class="p">(</span><span class="no">false</span><span class="p">)</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">is_boolean</span><span class="p">(</span><span class="ss">:false</span><span class="p">)</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">is_atom</span><span class="p">(</span><span class="ss">:hoge</span><span class="p">)</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">is_boolean</span><span class="p">(</span><span class="ss">:hoge</span><span class="p">)</span>
<span class="no">false</span>
</code></pre>

<h4>文字列の式展開 / 引用符による違い</h4>

<p>文字列は二重引用符で括って使う。<br>
文字列の結合は<code>+</code>ではなく<code>&lt;&gt;</code>だ。<br>
rubyと同様に<code>#{}</code>によって式を展開することも出来る。<br>
単一引用符を使おうとすると、少し驚く結果となるだろう。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="sd">"</span><span class="s2">foo"</span> <span class="o">+</span> <span class="sd">"</span><span class="s2">bar"</span>
<span class="o">**</span> <span class="p">(</span><span class="no">ArithmeticError</span><span class="p">)</span> <span class="n">bad</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">arithmetic</span> <span class="n">expression</span>
    <span class="ss">:erlang</span><span class="o">.+</span><span class="p">(</span><span class="sd">"</span><span class="s2">foo"</span><span class="p">,</span> <span class="sd">"</span><span class="s2">bar"</span><span class="p">)</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="sd">"</span><span class="s2">foo"</span> <span class="o">&lt;&gt;</span> <span class="sd">"</span><span class="s2">bar"</span>
<span class="sd">"</span><span class="s2">foobar"</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="sd">"</span><span class="s2">1 + 2 = </span><span class="si">#{</span><span class="m">1</span><span class="o">+</span><span class="m">2</span><span class="si">}</span><span class="s2">"</span>
<span class="sd">"</span><span class="s2">1 + 2 = 3"</span>
<span class="n">iex</span> <span class="s1">'日本語'</span>
<span class="p">[</span><span class="m">26085</span><span class="p">,</span> <span class="m">26412</span><span class="p">,</span> <span class="m">35486</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="sd">"</span><span class="s2">日本語"</span>
<span class="sd">"</span><span class="s2">日本語"</span>
</code></pre>

<p>これは文字列と文字のリストの違いが原因なんだ。</p>

<h4>リストとタプル</h4>

<p>単一引用符を使ったときに現れたものはリストなんだ。<br>
リストは<code>[]</code>を使って表現する。リストには何でも入れられる</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="no">true</span><span class="p">,</span> <span class="ss">:atom</span><span class="p">,</span> <span class="sd">"</span><span class="s2">string"</span><span class="p">,</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="no">true</span><span class="p">,</span> <span class="ss">:atom</span><span class="p">,</span> <span class="sd">"</span><span class="s2">string"</span><span class="p">,</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">]]</span>
</code></pre>

<p>リストと似ているタプルという物もある。<br>
タプルもリストと同じように何でも入れられる</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="no">true</span><span class="p">,</span> <span class="ss">:atom</span><span class="p">,</span> <span class="sd">"</span><span class="s2">string"</span><span class="p">,</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">],</span> <span class="p">{</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">}}</span>
<span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="no">true</span><span class="p">,</span> <span class="ss">:atom</span><span class="p">,</span> <span class="sd">"</span><span class="s2">string"</span><span class="p">,</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">],</span> <span class="p">{</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">}}</span>
</code></pre>

<p>似ているけれど、中身は違う。<br>
それはリストは中身が連結リスト（Linked list）であるのに対し、タプルは要素を連続したメモリ上に保存している点だ。<br>
タプルは連続したメモリ上に要素を持っているから、インデックスによる要素の取得や、要素数の取得は高速に出来る。<br>
対してリストは連結リストであるため、要素を順にたどる必要があり、タプルよりは低速になってしまう。<br>
リストの方が使い勝手が良い場合は要素を更新したり追加する時だ。<br>
elixrのデータ型は変更不可能なため、タプルの要素の更新はタプル全体をコピーしてから行う必要がある。<br>
リストの場合は途中の連結を変更するだけなので、タプルより簡単だ。<br>
リストとタプル、似てはいるけれど、適切に使い分けた方が良い。<br>
つまり変更されないような場合はタプル、変更される場合はリストといった具合だ。</p>

<p>リストとタプルについての操作も見てみよう。<br>
リストは<code>++/2</code>, <code>--/2</code>で連結や、差し引いたりが出来るし、<code>hd/1</code>, <code>tl/1</code>でリストの先頭とそれ以外の取得が出来る（LISPのcar, cdrみたいだね）。<br>
長さの取得は<code>length/1</code>を使う</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">]</span> <span class="o">--</span> <span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">hd</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">]</span>
<span class="m">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">tl</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">]</span>
<span class="p">[</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">]</span>
<span class="n">length</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">]</span>
<span class="m">3</span>
</code></pre>

<p>タプルのインデックスによる要素取得、サイズ取得、要素の変更はそれぞれ<code>elem/2</code>, <code>tuple_size/1</code>, <code>put_elem/3</code>を使う。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">elem</span><span class="p">({</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">},</span> <span class="m">1</span><span class="p">)</span>
<span class="m">2</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">tuple_size</span><span class="p">({</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">})</span>
<span class="m">3</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">put_elem</span><span class="p">({</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">},</span><span class="m">2</span><span class="p">,</span><span class="m">4</span><span class="p">)</span>
<span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">}</span>
</code></pre>

<p>リストの要素数取得が<code>length</code>で、タプルの要素数取得が<code>size</code>なのはちゃんと理由があるんだ。<br>
elixirではデータ構造が持っている要素数を数える場合、<br>
値があらかじめ計算されている場合は関数名に<code>size</code>を、明示的に計算が必要なものは関数名に<code>length</code>が使われている。<br>
自分で関数を作る場合にも気をつけてみよう。</p>

<h4>比較演算</h4>

<p>比較演算子には<code>==</code>，<code>!=</code>，<code>===</code>，<code>!==</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>&lt;</code>, <code>&gt;</code>が用意されている。<br>
基本的には想像通りの動作をする。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="o">==</span> <span class="m">1</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="o">!=</span> <span class="m">1</span>
<span class="no">false</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="m">2</span> <span class="o">&lt;=</span> <span class="m">2</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="m">2</span> <span class="o">&lt;</span> <span class="m">2</span>
<span class="no">false</span>
</code></pre>

<p><code>==</code>と<code>===</code>の違いは<code>===</code>の方が整数と浮動小数点数を厳密に比較する点だ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="o">==</span> <span class="m">1.0</span>
<span class="no">true</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="o">===</span> <span class="m">1.0</span>
<span class="no">false</span>
</code></pre>

<p>おもしろいのは異なる型の比較が出来る点だ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="o">&lt;</span> <span class="ss">:x</span>
<span class="no">true</span>
</code></pre>

<p>これは利便性のためで、以下のような型の比較ルールが用意されている。</p>
<pre class="highlight plaintext"><code>number &lt; atom &lt; reference &lt; functions &lt; port &lt; pid &lt; tuple &lt; maps &lt; list &lt; bitstring
</code></pre>

</section><section><header><h3>パターンマッチング</h3></header>

<p>今までのコードの中で、プログラムではよく使うのに、あえて登場させなかった演算子がある。<code>=</code>だ。<br>
使うのは簡単</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="m">1</span>
<span class="m">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="m">1</span>
</code></pre>

<p>結果も至極当然に見える。でも、次の例はどうだろうか</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">1</span> <span class="o">=</span> <span class="n">x</span>
<span class="m">1</span>
</code></pre>

<p>もしこれを<code>irb</code>で動かしていればシンタックスエラーだ。</p>
<pre class="highlight ruby"><code><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">=&gt;</span> <span class="mi">1</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">=</span> <span class="n">x</span>
<span class="no">SyntaxError</span><span class="p">:</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">unexpected</span> <span class="s1">'='</span><span class="p">,</span> <span class="n">expecting</span> <span class="k">end</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">input</span>
<span class="mi">1</span> <span class="o">=</span> <span class="n">x</span>
   <span class="o">^</span>
</code></pre>

<p>でもelixirでは<code>1 = x</code>はエラーにはならなかった。<br>
実はelixirの（もしくはErlangの）<code>=</code>は代入の演算子ではなく、パターンマッチングを行うマッチ演算子なんだ。<br>
<code>1 = x</code>はパターンマッチングとして成立しているからエラーにはならない。<br>
<code>2 = x</code>はマッチしないからエラーとなる。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="m">2</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="m">1</span>
</code></pre>

<p>マッチ演算子の左辺に変数があり、パターンマッチングが成立すれば変数に割り当てがされる。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="m">2</span>
<span class="m">2</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="m">2</span>
</code></pre>

<p>当然じゃ無いか、これなら代入と同じだと思うかもしれない、でもErlangよりはとっつきやすい。<br>
もしErlangで同じ事を実行したなら</p>

<p>注: Erlangの変数は大文字で始まる（Prologみたいだね）、そして式の最後にはピリオドがいる</p>
<pre class="highlight erlang"><code><span class="nv">Eshell</span> <span class="nv">V6</span><span class="p">.</span><span class="mi">3</span>  <span class="p">(</span><span class="n">abort</span> <span class="n">with</span> <span class="err">^</span><span class="nv">G</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="nv">X</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span>
<span class="mi">1</span>
<span class="o">&gt;</span> <span class="nv">X</span><span class="p">.</span>
<span class="mi">1</span>
<span class="o">&gt;</span> <span class="mi">1</span> <span class="o">=</span> <span class="nv">X</span><span class="p">.</span>
<span class="mi">1</span>
<span class="o">&gt;</span> <span class="mi">2</span> <span class="o">=</span> <span class="nv">X</span><span class="p">.</span>
<span class="o">**</span> <span class="n">exception</span> <span class="nn">error</span><span class="p">:</span> <span class="n">no</span> <span class="n">match</span> <span class="k">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="n">value</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="nv">X</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span>
<span class="o">**</span> <span class="n">exception</span> <span class="nn">error</span><span class="p">:</span> <span class="n">no</span> <span class="n">match</span> <span class="k">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="n">value</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="nv">X</span><span class="p">.</span>
<span class="mi">1</span>
</code></pre>

<p>そうErlangでは<code>X = 2</code>でもエラーとなる。<br>
全ての変数はイミュータブルであり、代入は1回だけに限られている。<br>
不便に思えるかもしれないけれど、関数型言語の考えを使うなら便利にもなる。<br>
elixirではピン演算子<code>^</code>によって再束縛をコントロールすることが出来る。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="o">^</span><span class="n">x</span> <span class="o">=</span> <span class="m">3</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="m">3</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="m">2</span>
</code></pre>

<p>徐々にパターンマッチングが代入と異なる点に踏み込んでみよう。<br>
マッチ演算子はリストやタプルの構造でも使うことが出来る。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="ss">:hoge</span><span class="p">,</span> <span class="sd">"</span><span class="s2">bar"</span><span class="p">}</span>
<span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="ss">:hoge</span><span class="p">,</span> <span class="sd">"</span><span class="s2">bar"</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="m">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">y</span>
<span class="ss">:hoge</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">z</span>
<span class="sd">"</span><span class="s2">bar"</span>
</code></pre>

<p>これだけだと一気に代入したのと変わらないように見えるけれど、左辺に変数以外があったらどうなるだろう。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="ss">:name</span><span class="p">,</span> <span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:name</span><span class="p">,</span> <span class="sd">"</span><span class="s2">taro"</span><span class="p">}</span>
<span class="p">{</span><span class="ss">:name</span><span class="p">,</span> <span class="sd">"</span><span class="s2">taro"</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="sd">"</span><span class="s2">taro"</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="ss">:name</span><span class="p">,</span> <span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:age</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="p">{</span><span class="ss">:age</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
</code></pre>

<p>この例だとタプルの先頭要素が<code>:name</code>の時のみ、変数<code>x</code>に割り当てが出来ると言うことだ。<br>
左辺に同じ変数を複数回使ったなら、同じものに束縛できなければパターンマッチングは成功しない。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
<span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
</code></pre>

<p>ピン演算子<code>^</code>は以前に束縛した値とのマッチングを表現できる。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="m">1</span>
<span class="m">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="o">^</span><span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
<span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="o">^</span><span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="o">^</span><span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
<span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="m">2</span>
</code></pre>

<p>パターンマッチングにおいて特殊な変数に<code>_</code>がある。<br>
これは簡単に言えばなんでもいいってことだ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="m">3</span>
</code></pre>

<h4>リストのパターンマッチング</h4>

<p>タプルと同じようにリストだってパターンマッチング出来る。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="ss">:hoge</span><span class="p">,</span> <span class="sd">"</span><span class="s2">bar"</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="ss">:hoge</span><span class="p">,</span> <span class="sd">"</span><span class="s2">bar"</span><span class="p">]</span>
</code></pre>

<p>リストの中身は連結リストだという話をしたよね、だから「先頭要素」と「続くリスト」というマッチングも出来る。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="ss">:hoge</span><span class="p">,</span> <span class="sd">"</span><span class="s2">bar"</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="ss">:hoge</span><span class="p">,</span> <span class="sd">"</span><span class="s2">bar"</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">head</span>
<span class="m">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">tail</span>
<span class="p">[</span><span class="ss">:hoge</span><span class="p">,</span> <span class="sd">"</span><span class="s2">bar"</span><span class="p">]</span>
</code></pre>

<p><code>[head | tail]</code>と指定したなら、先頭も続きも無い空のリストとはマッチングしない</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">tail</span>
<span class="p">[]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="p">[]</span>
</code></pre>

<p><code>[head | tail]</code>の書き方は実はマッチング以外にもリストそのものの表記としても使うことができる。<br>
簡単な例は先頭への要素の追加だ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="m">0</span> <span class="o">|</span> <span class="n">list</span><span class="p">]</span>
<span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span>
</code></pre>

<p><code>[1 | [2]]</code>と<code>[1 | 2]</code>は意味が違ってしまうから気をつけよう</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="m">1</span> <span class="o">|</span> <span class="p">[</span><span class="m">2</span><span class="p">]]</span>
<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">[</span><span class="m">1</span> <span class="o">|</span> <span class="m">2</span><span class="p">]</span>
<span class="p">[</span><span class="m">1</span> <span class="o">|</span> <span class="m">2</span><span class="p">]</span>
</code></pre>

</section><section><header><h3>キーワードリストとマップ</h3></header>

<p>リストは登場したけれど、まだ連想配列（RubyだとHash)を紹介していなかったね。<br>
elixirではキーワードリストとマップと呼ばれる2種類の連想データ構造があるんだ。</p>

<h4>キーワードリスト</h4>

<p>まずはキーワードリストだ。<br>
elixirでは，「最初の要素がアトムとなっているタプル」のリストをキーワードリストと呼ぶ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">k_list</span> <span class="o">=</span> <span class="p">[{</span><span class="ss">:x</span><span class="p">,</span> <span class="m">20</span><span class="p">},</span> <span class="p">{</span><span class="ss">:y</span><span class="p">,</span> <span class="m">30</span><span class="p">}]</span>
<span class="p">[</span><span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">]</span>
</code></pre>

<p>キーワードリストを使うとき、省略した記法もサポートされている。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">k_list</span> <span class="o">=</span> <span class="p">[</span><span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">]</span>
<span class="p">[</span><span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">]</span>
</code></pre>

<p>要素へのアクセスも出来る。指定のキーが無い場合は<code>nil</code>になる。<br>
rubyのHashと同じような使い勝手だね。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">k_list</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span>
<span class="m">20</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">k_list</span><span class="p">[</span><span class="ss">:z</span><span class="p">]</span>
<span class="no">nil</span>
</code></pre>

<p>キーワードリストはあくまで「タプルのリスト」だから、操作もリストと同じだ。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">k_list</span> <span class="o">++</span> <span class="p">[</span><span class="ss">z:</span> <span class="m">40</span><span class="p">]</span>
<span class="p">[</span><span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">z:</span> <span class="m">40</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">[{</span><span class="ss">:z</span><span class="p">,</span> <span class="m">40</span><span class="p">}</span> <span class="o">|</span> <span class="n">k_list</span><span class="p">]</span>
<span class="p">[</span><span class="ss">z:</span> <span class="m">40</span><span class="p">,</span> <span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">]</span>
</code></pre>

<p>あくまでリストだから、キーの順番は保たれるし、同じキーが複数回あってもいい。<br>
キーによるアクセス時、同一のキーがキーワードリスト内部にあっても、前方の値が優先される。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">new_list</span> <span class="o">=</span> <span class="n">k_list</span> <span class="o">++</span> <span class="p">[</span><span class="ss">z:</span> <span class="m">40</span><span class="p">,</span> <span class="ss">x:</span> <span class="m">10</span><span class="p">]</span>
<span class="p">[</span><span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">z:</span> <span class="m">40</span><span class="p">,</span> <span class="ss">x:</span> <span class="m">10</span><span class="p">]</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">new_list</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span>
<span class="m">20</span>
</code></pre>

<h4>マップ</h4>

<p>マップは<code>%{}</code>を使うと定義することができます。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">%{</span><span class="ss">:x</span> <span class="o">=&gt;</span> <span class="m">20</span><span class="p">,</span> <span class="ss">:y</span> <span class="o">=&gt;</span> <span class="m">30</span><span class="p">}</span>
<span class="p">%{</span><span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">}</span>
</code></pre>

<p>キーワードリストでは最初の要素がアトムでしたが、マップではキーをどんな値にもする事ができます。<br>
キーワードリストはキーの順序が保たれ、複数の同一キーも許されました、<br>
しかしマップではキーの順序は保たれず、もしマップを作るときに同じキーが渡されると最後の一つが優先されます。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">%{</span><span class="ss">:x</span> <span class="o">=&gt;</span> <span class="m">20</span><span class="p">,</span> <span class="ss">:x</span> <span class="o">=&gt;</span> <span class="m">30</span><span class="p">}</span>
<span class="p">%{</span><span class="ss">x:</span> <span class="m">30</span><span class="p">}</span>
</code></pre>

<p>マップのキーが全てアトムの場合はrubyのhash記法のように省略を使うことが出来ます。</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">%{</span><span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">}</span>
<span class="p">%{</span><span class="ss">x:</span> <span class="m">20</span><span class="p">,</span> <span class="ss">y:</span> <span class="m">30</span><span class="p">}</span>
</code></pre>

<p>マップは与えられたマップのキーがある部分にだけマッチするので、パターンマッチングに使いやすいです</p>
<pre class="highlight elixir"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="p">%{</span><span class="ss">name:</span> <span class="n">n</span><span class="p">,</span> <span class="ss">age:</span> <span class="n">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">,</span> <span class="ss">age:</span> <span class="m">30</span><span class="p">}</span>
<span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">n</span>
<span class="s1">'taro'</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="m">30</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">%{</span><span class="ss">name:</span> <span class="n">n</span><span class="p">}</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">,</span> <span class="ss">age:</span> <span class="m">30</span><span class="p">}</span>
<span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">n</span>
<span class="s1">'taro'</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">%{</span><span class="ss">name:</span> <span class="n">n</span><span class="p">}</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">}</span>
</code></pre>

<p>マップにはキーにアクセスするための構文が提供されています。</p>
<pre class="highlight elixir"><code><span class="c1"># 要素へのアクセス</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">,</span> <span class="ss">age:</span> <span class="m">30</span><span class="p">}</span>
<span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">.</span><span class="n">name</span>
<span class="s1">'taro'</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">.</span><span class="n">age</span>
<span class="m">30</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">.</span><span class="n">x</span>
<span class="o">**</span> <span class="p">(</span><span class="no">KeyError</span><span class="p">)</span> <span class="n">key</span> <span class="ss">:x</span> <span class="ow">not</span> <span class="n">found</span> <span class="ow">in</span><span class="p">:</span> <span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">}</span>

<span class="c1"># 要素の更新</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">%{</span><span class="n">map</span> <span class="o">|</span> <span class="ss">name:</span> <span class="s1">'ziro'</span><span class="p">}</span>
<span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">name:</span> <span class="s1">'ziro'</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span>
<span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="p">%{</span><span class="n">map</span> <span class="o">|</span> <span class="ss">x:</span> <span class="s1">'xxx'</span><span class="p">}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span> <span class="n">argument</span> <span class="n">error</span>
    <span class="p">(</span><span class="n">stdlib</span><span class="p">)</span> <span class="ss">:maps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="ss">:x</span><span class="p">,</span> <span class="s1">'xxx'</span><span class="p">,</span> <span class="p">%{</span><span class="ss">age:</span> <span class="m">30</span><span class="p">,</span> <span class="ss">name:</span> <span class="s1">'taro'</span><span class="p">})</span>
    <span class="p">(</span><span class="n">stdlib</span><span class="p">)</span> <span class="n">erl_eval</span><span class="o">.</span><span class="ss">erl:</span><span class="m">255</span><span class="p">:</span> <span class="n">anonymous</span> <span class="k">fn</span><span class="o">/</span><span class="m">2</span> <span class="ow">in</span> <span class="ss">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="m">5</span>
    <span class="p">(</span><span class="n">stdlib</span><span class="p">)</span> <span class="n">lists</span><span class="o">.</span><span class="ss">erl:</span><span class="m">1261</span><span class="p">:</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">foldl</span><span class="o">/</span><span class="m">3</span>
</code></pre>

</section><section><header><h3>まだ追記していくよ</h3></header>
</section>
</article>
</div>
</div>
</div>
</div>
<div id='footer'>
<div class='container'>
<div class='row'>
<!-- Posts -->
<section class='6u'>
<header>
<h2 class='fa fa-angle-left circled solo'>
<span>Next Article</span>
</h2>
</header>
<ul class='divided'>
<li>
<article class='post stub'>
<header>
<h3>
<a href="/article/2015/01/16/rails-on-pool/">Docker(pool)を用いたプレビュー環境を検証する</a>
</h3>
</header>
<span class='timestamp'>next article</span>
</article>
</li>
</ul>
</section>
<!-- Posts -->
<section class='6u'>
<header>
<h2 class='fa fa-angle-right circled solo'>
<span>Prev Article</span>
</h2>
</header>
<ul class='divided'>
<li>
<article class='post stub'>
<header>
<h3>
<a href="/article/2014/12/16/rails-tips/">早く知っておけば良かったrailsの技</a>
</h3>
</header>
<span class='timestamp'>prev article</span>
</article>
</li>
</ul>
</section>
</div>
</div>
</div>

</body>
</html>
